"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrate = exports.instantiate = exports.storeCode = void 0;
/* eslint-disable no-await-in-loop */
const terra_js_1 = require("@terra-money/terra.js");
const child_process_1 = require("child_process");
const config_1 = require("../config");
const waitForInclusionBlock_1 = require("./waitForInclusionBlock");
const fs = require("fs-extra");
const cli_ux_1 = require("cli-ux");
const YAML = require("yaml");
exports.storeCode = async ({ noRebuild, contract, signer, network, refsPath, lcd, codeId, arm64, }) => {
    process.chdir(`contracts/${contract}`);
    if (!noRebuild) {
        child_process_1.execSync("cargo wasm", { stdio: "inherit" });
        if (arm64) {
            // Need to use the rust-optimizer-arm64 image on arm64 architecture.
            child_process_1.execSync(`docker run --rm -v "$(pwd)":/code \
        --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
        --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
        cosmwasm/rust-optimizer-arm64:0.12.5`, { stdio: "inherit" });
        }
        else {
            child_process_1.execSync(`docker run --rm -v "$(pwd)":/code \
        --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
        --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
        cosmwasm/rust-optimizer:0.12.5`, { stdio: "inherit" });
        }
    }
    let wasmByteCodeFilename = `${contract.replace(/-/g, "_")}`;
    // rust-optimizer-arm64 produces a file with the `-aarch64` suffix.
    if (arm64) {
        wasmByteCodeFilename += '-aarch64';
    }
    wasmByteCodeFilename += '.wasm';
    const wasmByteCode = fs
        .readFileSync(`artifacts/${wasmByteCodeFilename}`)
        .toString("base64");
    cli_ux_1.cli.action.start("storing wasm bytecode on chain");
    const storeCodeTx = await signer.createAndSignTx({
        msgs: [
            typeof codeId !== "undefined"
                ? new terra_js_1.MsgMigrateCode(signer.key.accAddress, codeId, wasmByteCode)
                : new terra_js_1.MsgStoreCode(signer.key.accAddress, wasmByteCode),
        ],
    });
    const result = await lcd.tx.broadcastSync(storeCodeTx);
    if ('code' in result) {
        return cli_ux_1.cli.error(result.raw_log);
    }
    const res = await waitForInclusionBlock_1.waitForInclusionInBlock(lcd, result.txhash);
    cli_ux_1.cli.action.stop();
    if (typeof res === 'undefined') {
        return cli_ux_1.cli.error('transaction not included in a block before timeout');
    }
    try {
        const savedCodeId = JSON.parse((res && res.raw_log) || '')[0]
            .events.find((msg) => msg.type === "store_code")
            .attributes.find((attr) => attr.key === "code_id").value;
        process.chdir("../..");
        const updatedRefs = config_1.setCodeId(network, contract, savedCodeId)(config_1.loadRefs(refsPath));
        config_1.saveRefs(updatedRefs, refsPath);
        cli_ux_1.cli.log(`code is stored at code id: ${savedCodeId}`);
        return savedCodeId;
    }
    catch (error) {
        if (error instanceof SyntaxError) {
            cli_ux_1.cli.error(res.raw_log);
        }
        else {
            cli_ux_1.cli.error(`Unexpcted Error: ${error}`);
        }
    }
};
exports.instantiate = async ({ conf, refsPath, network, lcd, signer, admin, contract, codeId, instanceId, sequence, }) => {
    const instantiation = conf.instantiation;
    cli_ux_1.cli.action.start(`instantiating contract with code id: ${codeId}`);
    // Allow manual account sequences.
    const manualSequence = sequence || (await signer.sequence());
    const instantiateTx = await signer.createAndSignTx({
        sequence: manualSequence,
        msgs: [
            new terra_js_1.MsgInstantiateContract(signer.key.accAddress, admin, // can migrate
            codeId, instantiation.instantiateMsg),
        ],
    });
    const result = await lcd.tx.broadcastSync(instantiateTx);
    const res = await waitForInclusionBlock_1.waitForInclusionInBlock(lcd, result.txhash);
    let log = [];
    try {
        log = JSON.parse(res.raw_log);
    }
    catch (error) {
        cli_ux_1.cli.action.stop();
        if (error instanceof SyntaxError && res) {
            cli_ux_1.cli.error(res.raw_log);
        }
        else {
            cli_ux_1.cli.error(`Unexpcted Error: ${error}`);
        }
    }
    cli_ux_1.cli.action.stop();
    const contractAddress = log[0].events
        .find((event) => event.type === "instantiate_contract")
        .attributes.find((attr) => attr.key === "contract_address").value;
    const updatedRefs = config_1.setContractAddress(network, contract, instanceId, contractAddress)(config_1.loadRefs(refsPath));
    config_1.saveRefs(updatedRefs, refsPath);
    cli_ux_1.cli.log(YAML.stringify(log));
};
exports.migrate = async ({ conf, refsPath, lcd, signer, contract, codeId, network, instanceId, }) => {
    const instantiation = conf.instantiation;
    const refs = config_1.loadRefs(refsPath);
    const contractAddress = refs[network][contract].contractAddresses[instanceId];
    cli_ux_1.cli.action.start(`migrating contract with address ${contractAddress} to code id: ${codeId}`);
    const migrateTx = await signer.createAndSignTx({
        msgs: [
            new terra_js_1.MsgMigrateContract(signer.key.accAddress, contractAddress, codeId, instantiation.instantiateMsg),
        ],
    });
    const resInstant = await lcd.tx.broadcast(migrateTx);
    let log = [];
    try {
        log = JSON.parse(resInstant.raw_log);
    }
    catch (error) {
        cli_ux_1.cli.action.stop();
        if (error instanceof SyntaxError) {
            cli_ux_1.cli.error(resInstant.raw_log);
        }
        else {
            cli_ux_1.cli.error(`Unexpcted Error: ${error}`);
        }
    }
    cli_ux_1.cli.action.stop();
    const updatedRefs = config_1.setContractAddress(network, contract, instanceId, contractAddress)(config_1.loadRefs(refsPath));
    config_1.saveRefs(updatedRefs, refsPath);
    cli_ux_1.cli.log(YAML.stringify(log));
};
